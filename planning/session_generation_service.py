# planning/session_generation_service.py

from datetime import date, timedelta
from django.utils import timezone
from django.db import transaction

# Import your models (ensure all necessary models are imported)
from .models import ScheduledClass, Session, Player, Coach 

def generate_sessions_for_rules(
    scheduled_classes_qs, 
    period_start_date: date, 
    period_end_date: date,
    overwrite_existing_non_generated: bool = False 
    # Overwrite existing manually created sessions if they clash? Defaults to False (safer)
):
    """
    Generates Session instances based on ScheduledClass rules for a given date range.

    Args:
        scheduled_classes_qs: A queryset or list of active ScheduledClass instances.
        period_start_date: The start date for the generation period.
        period_end_date: The end date for the generation period.
        overwrite_existing_non_generated: If True, and a manually created session
                                          (not linked to any rule) clashes by group, date, and time,
                                          it will be updated and linked to the rule. 
                                          If False, such clashes will be skipped.

    Returns:
        A dictionary with counts: {'created': count, 'skipped_exists': count, 'skipped_inactive_rule': count, 'errors': count, 'details': list_of_messages}
    """
    from .models import Session # Import locally if there's any chance of circularity with models.py

    sessions_created_count = 0
    sessions_skipped_exists_count = 0
    sessions_skipped_inactive_rule_count = 0
    errors_count = 0
    action_details = []

    if period_start_date > period_end_date:
        action_details.append(f"Error: Start date ({period_start_date}) cannot be after end date ({period_end_date}).")
        return {'created': 0, 'skipped_exists': 0, 'skipped_inactive_rule': 0, 'errors': 1, 'details': action_details}

    current_date = period_start_date
    
    with transaction.atomic(): # Ensure all or nothing for a batch generation run
        while current_date <= period_end_date:
            current_day_of_week = current_date.weekday() # Monday is 0 and Sunday is 6

            for rule in scheduled_classes_qs:
                if not rule.is_active:
                    # Optional: Log that an inactive rule was skipped for this date
                    # action_details.append(f"Skipped inactive rule '{rule}' for date {current_date}")
                    # sessions_skipped_inactive_rule_count +=1 # Count this separately if desired
                    continue # Skip inactive rules

                if rule.day_of_week == current_day_of_week:
                    # Check if a session already exists for this rule, group, date, and time
                    existing_session_for_rule = Session.objects.filter(
                        generated_from_rule=rule,
                        session_date=current_date,
                        session_start_time=rule.start_time,
                        school_group=rule.school_group 
                        # Also consider venue if it's part of uniqueness for a rule
                    ).first()

                    if existing_session_for_rule:
                        action_details.append(f"Skipped: Session already exists (generated by this rule) for '{rule}' on {current_date}.")
                        sessions_skipped_exists_count += 1
                        continue

                    # More complex check: Does a manually created session clash?
                    # A clash is defined by same school_group, date, and start_time.
                    clashing_manual_session = Session.objects.filter(
                        school_group=rule.school_group,
                        session_date=current_date,
                        session_start_time=rule.start_time,
                        generated_from_rule__isnull=True # Manually created or from different system
                    ).first()

                    if clashing_manual_session:
                        if overwrite_existing_non_generated:
                            # Update the clashing manual session to link it to this rule
                            # and update its details from the rule.
                            clashing_manual_session.generated_from_rule = rule
                            clashing_manual_session.planned_duration_minutes = rule.default_duration_minutes
                            clashing_manual_session.venue = rule.default_venue # Use ForeignKey
                            clashing_manual_session.notes = f"(Updated from rule: {rule.id}) {clashing_manual_session.notes or ''}".strip()
                            # What about coaches and attendees? Overwrite or keep?
                            # For now, let's keep existing coaches/attendees on the manual session if it's updated.
                            # Or, set coaches from rule: clashing_manual_session.coaches_attending.set(rule.default_coaches.all())
                            clashing_manual_session.save()
                            sessions_created_count += 1 # Count as "created" in the sense of "processed by rule"
                            action_details.append(f"Updated: Manually created session for '{rule.school_group}' on {current_date} at {rule.start_time} was linked to rule '{rule}'.")
                        else:
                            action_details.append(f"Skipped: Manually created session exists for '{rule.school_group}' on {current_date} at {rule.start_time}. Rule '{rule}' not applied.")
                            sessions_skipped_exists_count += 1
                        continue # Move to next rule or day

                    # If no existing session found (neither by this rule nor a clashing manual one), create a new one
                    try:
                        new_session = Session.objects.create(
                            school_group=rule.school_group,
                            session_date=current_date,
                            session_start_time=rule.start_time,
                            planned_duration_minutes=rule.default_duration_minutes,
                            venue=rule.default_venue, # Use ForeignKey
                            notes=f"Generated from: {str(rule)}.\n{rule.notes_for_rule or ''}".strip(),
                            is_cancelled=False, # New sessions are not cancelled by default
                            # assessments_complete=False, # Default for this field
                            generated_from_rule=rule
                        )
                        # Assign default coaches
                        if rule.default_coaches.exists():
                            new_session.coaches_attending.set(rule.default_coaches.all())
                        
                        # Auto-populate attendees from the school group
                        if rule.school_group:
                            active_players_in_group = Player.objects.filter(
                                school_groups=rule.school_group, 
                                is_active=True
                            )
                            if active_players_in_group.exists():
                                new_session.attendees.set(active_players_in_group)
                        
                        sessions_created_count += 1
                        action_details.append(f"Created: Session for '{rule}' on {current_date}.")
                    except Exception as e:
                        errors_count += 1
                        action_details.append(f"Error creating session for '{rule}' on {current_date}: {e}")
                        print(f"Error details for {rule} on {current_date}: {e}")


            current_date += timedelta(days=1)

    return {
        'created': sessions_created_count,
        'skipped_exists': sessions_skipped_exists_count,
        'skipped_inactive_rule': sessions_skipped_inactive_rule_count, # You'd increment this if you track it
        'errors': errors_count,
        'details': action_details
    }

