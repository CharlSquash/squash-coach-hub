# planning/management/commands/generate_monthly_payslips.py

import io
from django.core.management.base import BaseCommand, CommandError
from django.utils import timezone
from django.core.files.base import ContentFile
from django.contrib.auth import get_user_model

from planning.models import Coach, Payslip # Your app's models
from planning.payslip_services import get_payslip_data_for_coach, generate_payslip_pdf_from_data # Services from Phase 2
from planning.payslip_services import create_all_payslips_for_period 
User = get_user_model()

class Command(BaseCommand):
    help = 'Generates monthly payslips for all eligible coaches for a specified month and year, or the previous month by default.'

    def add_arguments(self, parser):
        parser.add_argument(
            '--year',
            type=int,
            help="Year for payslip generation (e.g., 2025)"
        )
        parser.add_argument(
            '--month',
            type=int,
            help="Month for payslip generation (1-12)"
        )
        parser.add_argument(
            '--user_id',
            type=int,
            help="Optional ID of the User to be marked as 'generated_by'. This user should exist.",
            default=None # The service function will handle if this user exists or not
        )
        parser.add_argument(
            '--force',
            action='store_true',
            help="Force regeneration of payslips even if they already exist for the period.",
        )

    def handle(self, *args, **options):
        year = options['year']
        month = options['month']
        force_regeneration = options['force']
        generating_user_id_arg = options['user_id'] # Get the user_id from arguments
        
        # Determine default year/month if not specified
        if not year or not month:
            today = timezone.now()
            first_day_of_current_month = today.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
            last_day_of_previous_month = first_day_of_current_month - timezone.timedelta(days=1)
            year = last_day_of_previous_month.year
            month = last_day_of_previous_month.month
            self.stdout.write(self.style.NOTICE(f"Year/Month not specified. Defaulting to previous month: {month:02}/{year}"))
        else:
            self.stdout.write(self.style.SUCCESS(f"Targeting payslip generation for: {month:02}/{year}"))

        if generating_user_id_arg:
             # Optional: You could add a check here to see if user exists before calling the service,
             # but the service function also has a notice if user_id is provided but user not found.
            try:
                user_check = User.objects.get(pk=generating_user_id_arg)
                self.stdout.write(self.style.NOTICE(f"Attempting to mark payslips as generated by: {user_check.username} (ID: {generating_user_id_arg})"))
            except User.DoesNotExist:
                self.stdout.write(self.style.WARNING(f"User with ID {generating_user_id_arg} specified via --user_id was not found. 'generated_by' may be null."))
                # The service function will also print a warning and handle generating_user as None.

        # Call the refactored service function
        # Pass generating_user_id_arg directly
        results = create_all_payslips_for_period(year, month, generating_user_id_arg, force_regeneration)

        # Output the results to the console
        self.stdout.write(self.style.SUCCESS(f"\n--- Payslip Generation Summary for {month:02}/{year} ---"))
        self.stdout.write(self.style.SUCCESS(f"Successfully generated: {results['generated_count']}"))
        self.stdout.write(self.style.NOTICE(f"Skipped (already exists or no data): {results['skipped_count']}"))
        self.stdout.write(self.style.ERROR(f"Errors encountered: {results['error_count']}"))
        
        if results.get('details'):
            self.stdout.write(self.style.NOTICE("\n--- Detailed Log ---"))
            for detail_msg in results['details']:
                if "Error deleting" in detail_msg or "Error saving" in detail_msg or "Failed to generate PDF" in detail_msg:
                    self.stdout.write(self.style.ERROR(f"  {detail_msg}"))
                elif "Existing payslip found" in detail_msg and "Forcing regeneration" in detail_msg:
                    self.stdout.write(self.style.WARNING(f"  {detail_msg}"))
                elif "Skipping" in detail_msg or "No payslip data" in detail_msg or "already exists" in detail_msg:
                    self.stdout.write(self.style.NOTICE(f"  {detail_msg}"))
                elif "Successfully generated and saved" in detail_msg or "Successfully deleted existing" in detail_msg :
                    self.stdout.write(self.style.SUCCESS(f"  {detail_msg}"))
                elif "Starting payslip generation" in detail_msg or "Payslips will be marked" in detail_msg or "Processing coach" in detail_msg:
                    self.stdout.write(detail_msg) # General info
                elif results['summary_message'] == detail_msg: # Avoid printing summary twice if it's the last detail
                    pass
                else: # Default for other messages
                    self.stdout.write(f"  {detail_msg}")
        
        self.stdout.write(self.style.SUCCESS("--- Process Complete ---"))